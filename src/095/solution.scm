(import
  (chicken fixnum)
  (euler)
  (srfi 69))

(define (make-divisors-sum n)
  (let acc ((acc (make-vector (fx+ n 1) 0)))
    (let loop ((i 1))
      (unless (fx> i n)
        (let subloop ((m (fx+ i i)))
          (unless (fx> m n)
            (vector-set! acc m (fx+ (vector-ref acc m) i))
            (subloop (fx+ m i))))
        (loop (fx+ i 1))))
    (define (divisors-sum n)
      (vector-ref acc n))
    divisors-sum))

(define (make-chain n)
  (let ((divisors-sum (make-divisors-sum n)) (limit n))
    (define (chain n)
      (let ((mem (make-hash-table)))
        (let loop ((i n) (acc '()))
          (if (and (fx= i n) (not (null? acc)))
            acc
            (if (fx> i limit)
              '()
              (if (hash-table-exists? mem i)
                '()
                (begin
                  (hash-table-set! mem i #t)
                  (loop (divisors-sum i) (cons i acc)))))))))
    chain))

(define (solve n)
  (let ((chain (make-chain n)))
    (let loop ((i 0) (tmp 0) (acc '()))
      (if (fx> i n)
        (foldl fxmin (car acc) (cdr acc))
        (let* ((c (chain i)) (l (length c)))
          (if (fx> l tmp)
            (loop (fx+ i 1) l c)
            (loop (fx+ i 1) tmp acc)))))))

(let ((_ (solve #e1e6)))
  (print _) (assert (= _ 14316)))
