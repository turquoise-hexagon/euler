(import
  (euler))

(define (exact n)
  (inexact->exact (floor n)))

(define (make-factorial n p)
  (let loop ((acc (make-vector (+ n 1))))
    (vector-set! acc 0 1)
    (do ((i 1 (+ i 1))) ((> i n))
      (vector-set! acc i (modulo (* (vector-ref acc (- i 1)) i) p)))
    (lambda (n)
      (vector-ref acc n))))

(define (make-binomial n p)
  (let ((factorial (make-factorial n p)))
    (lambda (n k)
      (let ((a (factorial n))
            (b (factorial k))
            (c (factorial (- n k))))
        (modulo (* a (modular-inverse (modulo (* b c) p) p)) p)))))

(define (make-function n p)
  (let ((binomial (make-binomial n p)))
    (lambda (a x)
      (let ((l (exact (/ x a))))
        (do ((i 0 (+ i 1))
             (acc 0 (modulo (+ acc (binomial (exact (- x (* (- a 1) i))) i)) p)))
          ((> i l) acc))))))

(define (solve a b p)
  (let ((function (make-function b p)))
    (do ((i a (+ i 1))
         (acc 0 (if (prime? i)
                  (modulo (+ acc (function (sqrt i) i)) p)
                  acc)))
      ((> i b) acc))))

(let ((_ (solve 10000000 10010000 1000000007)))
  (print _) (assert (= _ 581468882)))
